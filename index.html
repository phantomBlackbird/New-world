<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Subrural - Fixed Version with Animated Ground</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    
    <style>
      body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
      
      .controller {
        position: absolute; 
        bottom: 40px; 
        width: 220px; 
        height: 220px; 
        z-index: 2000;
        display: grid; 
        gap: 10px; 
        pointer-events: auto;
      }
      
      #move-pad { 
        left: 20px; 
        grid-template-areas: 
          ". up ." 
          "left . right" 
          ". down ."; 
      }
      
      .btn {
        width: 70px; 
        height: 70px; 
        background: rgba(0, 0, 0, 0.6); 
        border: 2px solid rgba(255, 255, 255, 0.8);
        border-radius: 50%; 
        display: flex; 
        align-items: center; 
        justify-content: center;
        font-size: 14px; 
        font-weight: bold; 
        color: white; 
        user-select: none; 
        touch-action: none;
        backdrop-filter: blur(4px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        transition: all 0.1s ease;
      }
      
      .btn:active { 
        background: rgba(255, 255, 255, 0.9); 
        color: black; 
        transform: scale(0.95);
      }
      
      .btn.sprinting {
        background: rgba(255, 100, 100, 0.8);
        border-color: #ff0;
      }
      
      #up { grid-area: up; } 
      #left { grid-area: left; } 
      #right { grid-area: right; } 
      #down { grid-area: down; }
      
      #sprint-indicator {
        position: absolute;
        bottom: 280px;
        left: 50px;
        width: 100px;
        height: 10px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 5px;
        z-index: 2001;
        overflow: hidden;
        display: none;
      }
      
      #sprint-progress {
        width: 0%;
        height: 100%;
        background: #ffaa00;
        transition: width 0.1s linear;
      }
      
      @media (max-width: 400px) {
        .controller { transform: scale(0.8); left: 0; bottom: 20px; }
        #sprint-indicator { left: 30px; bottom: 240px; }
      }
    </style>
  </head>
  <body>
    <!-- Sprint progress indicator -->
    <div id="sprint-indicator">
      <div id="sprint-progress"></div>
    </div>

    <!-- Movement controls -->
    <div id="move-pad" class="controller">
      <div class="btn" id="up">FWD</div>
      <div class="btn" id="left">←</div>
      <div class="btn" id="right">→</div>
      <div class="btn" id="down">BWD</div>
    </div>

    <a-scene physics="gravity: 0" renderer="antialias: true; colorManagement: true">
      <a-assets>
        <a-asset-item id="subrural" src="Subrural.glb"></a-asset-item>
        <a-asset-item id="player" src="Player.glb"></a-asset-item>
        <a-asset-item id="ground" src="Ground.glb"></a-asset-item>
      </a-assets>

      <!-- Environment -->
      <a-entity gltf-model="#subrural" position="0 0 0"></a-entity>
      
      <!-- Animated Ground with physics -->
      <a-entity gltf-model="#ground" 
                position="0 0 0" 
                static-body
                shadow="receive: true"
                animation-mixer="clip: idle">
      </a-entity>
      
      <a-sky color="#87CEEB"></a-sky>

      <!-- Player Rig -->
      <a-entity id="player-rig" position="0 0.05 0">
        
        <!-- Player Model with animation mixer -->
        <a-entity id="player-model" 
                  gltf-model="#player" 
                  scale="0.0092 0.0092 0.0092" 
                  rotation="0 180 0"
                  animation-mixer="clip: idle; crossFadeDuration: 0.2">
        </a-entity>

        <!-- Camera positioned behind the character -->
        <a-entity id="camera-rig" position="0 1.8 -3">
          <a-entity id="camera" 
                    camera 
                    look-controls="pointerLockEnabled: false; enabled: true"
                    wasd-controls="enabled: false">
          </a-entity>
        </a-entity>
      </a-entity>

      <!-- Lighting -->
      <a-entity light="type: ambient; intensity: 0.8"></a-entity>
      <a-entity light="type: directional; intensity: 0.8; castShadow: true" 
                position="5 10 5" 
                target="0 0 0">
      </a-entity>
    </a-scene>

    <script>
      (function() {
        // Wait for scene to load
        const scene = document.querySelector('a-scene');
        if (!scene) {
          console.error('Scene not found');
          return;
        }

        scene.addEventListener('loaded', () => {
          console.log('Scene loaded, initializing controls...');
          
          // Get references with null checks
          const rig = document.getElementById('player-rig');
          const model = document.getElementById('player-model');
          const camera = document.getElementById('camera');
          const sprintProgress = document.getElementById('sprint-progress');
          const sprintIndicator = document.getElementById('sprint-indicator');
          
          if (!rig || !model) {
            console.error('Required elements not found');
            return;
          }

          // Movement state
          let moveKeys = { up: false, down: false, left: false, right: false };
          let isRunning = false;
          let sprintCharge = 0;
          const SPRINT_DELAY = 3000; // 3 seconds
          const BOUNDARY = 50; // Movement boundary
          
          // Sprint timers per key
          let sprintTimers = { up: null, down: null, left: null, right: null };
          
          // Frame timing for smooth movement
          let lastTime = performance.now();
          
          // Animation state tracking
          let currentAnim = 'idle';
          
          // Button setup function with improved touch handling
          const setupButton = (id, key) => {
            const el = document.getElementById(id);
            if (!el) {
              console.error(`Button ${id} not found`);
              return;
            }
            
            const start = (e) => {
              e.preventDefault();
              e.stopPropagation();
              moveKeys[key] = true;
              
              // Show sprint indicator
              if (sprintIndicator) sprintIndicator.style.display = 'block';
              
              // Start sprint timer for this key
              if (!sprintTimers[key]) {
                sprintTimers[key] = setTimeout(() => {
                  isRunning = true;
                  el.classList.add('sprinting');
                  sprintCharge = 100;
                  if (sprintProgress) sprintProgress.style.width = '100%';
                }, SPRINT_DELAY);
              }
              
              // Update sprint progress
              const startTime = Date.now();
              const updateProgress = () => {
                if (moveKeys[key] && !isRunning) {
                  const elapsed = Date.now() - startTime;
                  const progress = Math.min(100, (elapsed / SPRINT_DELAY) * 100);
                  if (sprintProgress) sprintProgress.style.width = progress + '%';
                  requestAnimationFrame(updateProgress);
                }
              };
              updateProgress();
            };
            
            const end = (e) => {
              e.preventDefault();
              e.stopPropagation();
              moveKeys[key] = false;
              
              // Hide sprint indicator if no keys pressed
              if (!moveKeys.up && !moveKeys.down && !moveKeys.left && !moveKeys.right) {
                if (sprintIndicator) sprintIndicator.style.display = 'none';
              }
              
              // Clear sprint timer for this key
              if (sprintTimers[key]) {
                clearTimeout(sprintTimers[key]);
                sprintTimers[key] = null;
              }
              
              // Reset running if no other movement keys are pressed
              if (!moveKeys.up && !moveKeys.down) {
                isRunning = false;
                el.classList.remove('sprinting');
                sprintCharge = 0;
                if (sprintProgress) sprintProgress.style.width = '0%';
              }
            };
            
            // Add event listeners
            el.addEventListener('touchstart', start, { passive: false });
            el.addEventListener('touchend', end, { passive: false });
            el.addEventListener('touchcancel', end, { passive: false });
            el.addEventListener('mousedown', start);
            el.addEventListener('mouseup', end);
            el.addEventListener('mouseleave', end);
          };

          // Setup all buttons
          setupButton('up', 'up');
          setupButton('down', 'down');
          setupButton('left', 'left');
          setupButton('right', 'right');

          // Keyboard controls for testing
          window.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
              case 'w': moveKeys.up = true; e.preventDefault(); break;
              case 's': moveKeys.down = true; e.preventDefault(); break;
              case 'a': moveKeys.left = true; e.preventDefault(); break;
              case 'd': moveKeys.right = true; e.preventDefault(); break;
            }
          });
          
          window.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
              case 'w': moveKeys.up = false; e.preventDefault(); break;
              case 's': moveKeys.down = false; e.preventDefault(); break;
              case 'a': moveKeys.left = false; e.preventDefault(); break;
              case 'd': moveKeys.right = false; e.preventDefault(); break;
            }
            
            // Reset running if no forward/back movement
            if (!moveKeys.up && !moveKeys.down) {
              isRunning = false;
              document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('sprinting'));
            }
          });

          // Animation validation function
          const validateAndSetAnimation = (newAnim) => {
            if (newAnim !== currentAnim) {
              // Only set if different
              model.setAttribute('animation-mixer', `clip: ${newAnim}; crossFadeDuration: 0.2`);
              currentAnim = newAnim;
              console.log(`Animation set to: ${newAnim}`); // For debugging
            }
          };

          // Main game loop
          function tick() {
            if (!rig || !model) return;
            
            const now = performance.now();
            const delta = Math.min(32, now - lastTime) / 16; // Cap at 2x speed
            lastTime = now;
            
            try {
              // Get current rotation with fallback
              let rotation = rig.getAttribute('rotation');
              if (!rotation) rotation = { x: 0, y: 0, z: 0 };
              
              // Handle rotation (left/right)
              if (moveKeys.left) rotation.y += 2.5 * delta;
              if (moveKeys.right) rotation.y -= 2.5 * delta;
              
              // Normalize rotation
              rotation.y = rotation.y % 360;
              if (rotation.y < 0) rotation.y += 360;
              
              rig.setAttribute('rotation', rotation);
              
              // Handle position (forward/backward)
              let position = rig.getAttribute('position');
              if (!position) position = { x: 0, y: 0.05, z: 0 };
              
              // Calculate speed with delta
              const baseSpeed = 0.05;
              const runSpeed = 0.12;
              let speed = (isRunning ? runSpeed : baseSpeed) * delta;
              
              // Determine animation and move
              let targetAnim = 'idle';
              
              if (moveKeys.up || moveKeys.down) {
                const direction = moveKeys.up ? 1 : -1;
                const angleRad = rotation.y * (Math.PI / 180);
                
                // Move relative to camera direction
                position.x -= Math.sin(angleRad) * speed * direction;
                position.z -= Math.cos(angleRad) * speed * direction;
                
                // Apply boundaries
                position.x = Math.max(-BOUNDARY, Math.min(BOUNDARY, position.x));
                position.z = Math.max(-BOUNDARY, Math.min(BOUNDARY, position.z));
                
                // Set animation based on direction and running state
                if (direction === 1) {
                  targetAnim = isRunning ? 'run-forward' : 'walk-forward';
                } else {
                  targetAnim = isRunning ? 'run-backwards' : 'walk-backwards';
                }
              }
              
              // Update position
              rig.setAttribute('position', position);
              
              // Update animation
              validateAndSetAnimation(targetAnim);
              
            } catch (error) {
              console.error('Error in game loop:', error);
            }
            
            requestAnimationFrame(tick);
          }

          // Start the game loop
          tick();

          // Handle model loading errors
          model.addEventListener('model-error', (error) => {
            console.error('Failed to load player model:', error);
            // Fallback to a simple shape if model fails
            model.setAttribute('geometry', 'primitive: capsule; height: 2; radius: 0.5');
            model.setAttribute('material', 'color: #4CAF50');
          });

          // Log success
          console.log('Controls initialized successfully');
        });
      })();
    </script>
  </body>
  </html>
